/**
 * LICENSE + COPYRIGHT
 */
package org.emergent.bzr4j.core.xmloutput;

import org.emergent.bzr4j.core.BazaarException;
import org.emergent.bzr4j.core.IBazaarLogMessage;
import org.emergent.bzr4j.core.IBazaarStatus;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * I'm a parser for the output generated by the command: log --xml (using
 * bzr-xmloutput plugin), and with that output I create a
 * Set&lt;IBazaarLogMessage&gt;
 *
 * @author Guillermo Gonzalez
 * @author Phan Minh Thang
 */
class XmlLogParser extends XmlAbstractParser {

  public static final String REVNO = "revno";

  public static final String REVISION_ID = "revisionid";

  public static final String COMMITER = "committer";

  public static final String BRANCH_NICK = "branch-nick";

  public static final String TIMESTAMP = "timestamp";

  public static final String MESSAGE = "message";

  public static final String LOG = "log";

  public static final String TAGS = "tags";

  public static final String PARENTS = "parents";

  public static final String PARENT = "parent";

  public static final String MERGE = "merge";

  public static final String FILES = "affected-files";

  /**
   *
   * @param xml a String containing the xml to be parsed
   * @return List<IBazaarLogMessage> a unmodifiable and ordered (by revno) list of log msgs
   * @throws BazaarException if a problem occurs
   */
  public static List<IBazaarLogMessage> parse(String xml) throws BazaarException {
    return parse(new StringReader(xml));
  }

  /**
   *
   * @param aReader a reader for the xml input
   * @return List<IBazaarLogMessage> a unmodifiable and ordered (by revno) list of log msgs
   * @throws BazaarException if a problem occurs
   */
  public static List<IBazaarLogMessage> parse(Reader aReader) throws BazaarException {
    try {
      XMLInputFactory factory = XMLInputFactory.newInstance();
      XMLStreamReader parser = factory.createXMLStreamReader(aReader);
      return new XmlLogParser().parse(parser);
    }
    catch (XMLStreamException e) {
      throw new BazaarException(e);
    }
  }

  protected List<IBazaarLogMessage> parse(XMLStreamReader aParser) throws BazaarException {
    // more efficient to reference a stack variable(within a method) instead of a class variable. everytime you do an add etc.
    final List<IBazaarLogMessage> logs = new ArrayList<IBazaarLogMessage>();
    this.parser = aParser;
    try {
      int eventType = parser.getEventType();
      // iterate over all tags (actually only care about first level <log/> tags)
      while (eventType != XMLStreamConstants.END_DOCUMENT) {
        if (eventType == XMLStreamConstants.START_ELEMENT && LOG.equals(parser.getLocalName())) {
          IBazaarLogMessage log = parseLog();
          if (log != null) {
            logs.add(log);
            if (log.getMerged().size() > 0) {
              logs.addAll(log.getMerged());
            }
          }
        }
        eventType = parser.next();
      }
    }
    catch (XMLStreamException e) {
      throw new BazaarException(e);
    }
    catch (IOException e) {
      throw new BazaarException(e);
    }
    Collections.sort(logs, new IBazaarLogMessage.LogMessageComparator());
    return logs;
  }

  /**
   * This method parse one <log>...</log> including <merge/>
   * @throws IOException if a problem occurs
   * @throws XMLStreamException if a problem occurs
   */
  protected IBazaarLogMessage parseLog() throws XMLStreamException, IOException {
    XmlBazaarLogMessage.Builder builder = new XmlBazaarLogMessage.Builder();
    final XmlStatusParser statusParser = new XmlStatusParser();
    String revno, commiter, nick, timestamp, message, revisionId;
    revno = commiter = nick = timestamp = message = revisionId = null;
    List<String> parents = null;
    List<IBazaarStatus> statuses = null;
    final List<IBazaarLogMessage> mergedLogs = new ArrayList<IBazaarLogMessage>();
    int eventType = parser.next();
    while (!(eventType == XMLStreamConstants.END_ELEMENT && LOG.equals(parser.getLocalName()))
        || eventType == XMLStreamConstants.END_DOCUMENT) {
      if (eventType == XMLStreamConstants.START_ELEMENT && REVNO.equals(parser.getLocalName())) {
        revno = parser.getElementText();
      } else if (eventType == XMLStreamConstants.START_ELEMENT && REVISION_ID.equals(parser.getLocalName())) {
        revisionId = parser.getElementText();
      } else if (eventType == XMLStreamConstants.START_ELEMENT && PARENTS.equals(parser.getLocalName())) {
        parents = parseParents();
      } else if (eventType == XMLStreamConstants.START_ELEMENT && COMMITER.equals(parser.getLocalName())) {
        commiter = parser.getElementText();
      } else if (eventType == XMLStreamConstants.START_ELEMENT && BRANCH_NICK.equals(parser.getLocalName())) {
        nick = parser.getElementText();
      } else if (eventType == XMLStreamConstants.START_ELEMENT && TIMESTAMP.equals(parser.getLocalName())) {
        timestamp = parser.getElementText();
      } else if (eventType == XMLStreamConstants.START_ELEMENT && MESSAGE.equals(parser.getLocalName())) {
        // FIXME: for some reason \b and \t are not correctly handled in client <-> server
        final String rawMsg = parser.getElementText();
        message = rawMsg != null ? rawMsg.replace("\\x0c", "\f").replace("\\x09", "\t")
            .replace("\\x08", "\b") : "(no message)";
      } else if (eventType == XMLStreamConstants.START_ELEMENT && MERGE.equals(parser.getLocalName())) {
        mergedLogs.addAll(parseMergedLogs());
      } else if (eventType == XMLStreamConstants.START_ELEMENT && FILES.equals(parser.getLocalName())) {
        statuses = statusParser.parseForLog(parser, FILES);
      }
      eventType = parser.next();
    }
    return builder
        .setRevno(revno)
        .setCommiter(commiter)
        .setNick(nick)
        .setTimestamp(timestamp)
        .setMessage(message)
        .setResourceStatus(statuses)
        .setMerged(mergedLogs)
        .setRevisionId(revisionId)
        .setParents(parents)
        .createBazaarLogMessage();
  }

  private List<IBazaarLogMessage> parseMergedLogs() throws XMLStreamException, IOException {
    List<IBazaarLogMessage> logs = new ArrayList<IBazaarLogMessage>(0);
    int eventType = parser.next();
    int mergeCounter = 1;
    while (mergeCounter > 0) {
      if (eventType == XMLStreamConstants.START_ELEMENT && MERGE.equals(parser.getLocalName())) {
        mergeCounter++;
      } else if (eventType == XMLStreamConstants.START_ELEMENT && LOG.equals(parser.getLocalName())) {
        logs.add(parseLog());
      }
      eventType = parser.next();
      if (eventType == XMLStreamConstants.END_ELEMENT && MERGE.equals(parser.getLocalName())) {
        mergeCounter--;
      }
    }
    Collections.sort(logs, new IBazaarLogMessage.LogMessageComparator());
    return logs;
  }

  private List<String> parseParents() throws XMLStreamException, IOException {
    final List<String> parents = new ArrayList<String>(0);
    int eventType = parser.next();
    while (eventType != XMLStreamConstants.END_ELEMENT && !PARENTS.equals(parser.getLocalName())) {
      if (eventType == XMLStreamConstants.START_ELEMENT && PARENT.equals(parser.getLocalName())) {
        parents.add(parser.getElementText());
      }
      eventType = parser.next();
    }
    return parents;
  }
}
