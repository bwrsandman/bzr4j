/**
 * LICENSE + COPYRIGHT
 */
package org.emergent.bzr4j.core.commandline.parser;

import org.emergent.bzr4j.core.BazaarStatusKind;
import org.emergent.bzr4j.core.BazaarStatusType;
import org.emergent.bzr4j.core.commandline.parser.CommandLineStatus;
import org.emergent.bzr4j.core.BazaarException;
import org.emergent.bzr4j.core.IBazaarLogMessage;
import org.emergent.bzr4j.core.IBazaarStatus;
import org.emergent.bzr4j.core.utils.StringUtil;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * I'm a parser for the output generated by th command: status --xml (usign
 * bzr-xmloutput plugin), and with that output I create a
 * Set&lt;IBazaarStatus&gt;
 *
 * @author Guillermo Gonzalez
 */
class XMLStatusParser extends XmlAbstractParser implements XmlStatusResult {

  private final List<IBazaarStatus> statuses = new ArrayList<IBazaarStatus>(0);

  private List<IBazaarLogMessage> pendingMerges = null;

  private Set<IBazaarStatus> statusSet = null;

  private final static String ADDED = "added";

  private final static String REMOVED = "removed";

  private final static String RENAMED = "renamed";

  private final static String MODIFIED = "modified";

  private final static String KIND_CHANGED = "kind-changed";

  private final static String UNKNOWN = "unknown";

  private final static String FILE = "file";

  private final static String DIR = "directory";

  private final static String OLDKIND = "oldkind";

  private final static String NEWKIND = "newkind";

  private final static String OLDPATH = "oldpath";

  private final static String FID = "fid";

  private final static String SUFFIX = "suffix";

  private final static String STATUS = "status";

  private final static String BRANCH_ROOT = "workingtree_root";

  private final static String CONFLICTS = "conflicts";

  private final static String CONFLICT = "conflict";

  private final static String TYPE = "type";

  private final static String PENDING_MERGES = "pending_merges";

  public void parse(final String xml) throws BazaarException {
    try {
      XMLInputFactory factory = XMLInputFactory.newInstance();
      parser = factory.createXMLStreamReader(new StringReader(xml));
      int eventType = parser.getEventType();
      while (eventType != XMLStreamConstants.END_DOCUMENT) {
        if (eventType == XMLStreamConstants.START_ELEMENT && isGroup(parser.getLocalName())) {
          parseGroup();
        } else if (eventType == XMLStreamConstants.START_ELEMENT && STATUS.equals(parser.getLocalName())) {
          workDir = new File(parser.getAttributeValue(null, BRANCH_ROOT));
        } else if (eventType == XMLStreamConstants.START_ELEMENT && PENDING_MERGES.equals(parser.getLocalName())) {
          parsePendingMerges();
        }
        eventType = parser.next();
      }
    }
    catch (XMLStreamException e) {
      throw new BazaarException(e);
    }
    catch (IOException e) {
      throw new BazaarException(e);
    }
    statusSet = orderAndCleanup();
  }

  public Set<IBazaarStatus> getStatusSet() {
    return statusSet;
  }

  public List<IBazaarLogMessage> getPendingMerges() {
    if (pendingMerges == null) {
      pendingMerges = Collections.EMPTY_LIST;
    }
    return pendingMerges;
  }

  private void parsePendingMerges() throws BazaarException {
    LOG.debug("Parsing pending merges");
    try {
      pendingMerges = new XMLLogParser().parse(parser);
    }
    catch (Exception e) {
      LOG.error("unexpected error while parsing pending merges: ", e);
      pendingMerges = null;
    }
    if (pendingMerges == null) {
      pendingMerges = new ArrayList<IBazaarLogMessage>(0);
    }
  }

  private boolean isGroup(String name) {
    return (name.equals(ADDED) || name.equals(REMOVED) || name.equals(RENAMED)
        || name.equals(MODIFIED) || name.equals(KIND_CHANGED)
        || name.equals(UNKNOWN)) || name.equals(CONFLICTS);
  }

  private void parseGroup() throws XMLStreamException, IOException {
    String group = parser.getLocalName();
    LOG.debug("Parsing status group: " + group);
    int eventType = parser.next();
    while (eventType != XMLStreamConstants.END_DOCUMENT) {
      if (eventType == XMLStreamConstants.START_ELEMENT && CONFLICT.equals(parser.getLocalName())) {
        final String type = parser.getAttributeValue(null, TYPE);
        final String path = StringUtil.nullSafeTrim(parser.getElementText());
        if ((path.endsWith(".BASE") || path.endsWith(".THIS") || path.endsWith(".OTHER"))) {
          eventType = parser.next();
          continue;
        }
        // TODO: add conflict type enum
        final IBazaarStatus status =
            new CommandLineStatus(getStatusType(group), getAsFile(path), null, BazaarStatusKind.conflict, null, workDir);
        statuses.add(status);
      } else if (eventType == XMLStreamConstants.START_ELEMENT &&
          (FILE.equals(parser.getLocalName()) || DIR.equals(parser.getLocalName()))) {
        String path, prevPath;
        path = prevPath = null;
        BazaarStatusKind newKind;
        BazaarStatusKind oldKind = null;
        if (FILE.equals(parser.getLocalName())) {
          newKind = BazaarStatusKind.file;
        } else {
          newKind = BazaarStatusKind.directory;
        }
        for (int i = 0; i < parser.getAttributeCount(); i++) {
          if (parser.getAttributeLocalName(i).equals(OLDKIND)) {
            oldKind = BazaarStatusKind.valueOf(StringUtil.nullSafeTrim(parser.getAttributeValue(i)));
          } else if (parser.getAttributeLocalName(i).equals(OLDPATH)) {
            prevPath = StringUtil.nullSafeTrim(parser.getAttributeValue(i));
          } else if (parser.getAttributeLocalName(i).equals(FID)) {
            // do nothing (for the moment)
          } else if (parser.getAttributeLocalName(i).equals(SUFFIX)) {
            // do nothing (for the moment)
          }
        }
        path = StringUtil.nullSafeTrim(parser.getElementText());
        if (path.endsWith(".BASE") || path.endsWith(".THIS") || path.endsWith(".OTHER")) {
          eventType = parser.next();
          continue;
        }
        final IBazaarStatus status = new CommandLineStatus(
            getStatusType(group), getAsFile(path),
            getAsFile(prevPath), newKind, oldKind, workDir);
        statuses.add(status);
      } else if (eventType == XMLStreamConstants.END_ELEMENT && group.equals(parser.getLocalName())) {
        return;
      }
      eventType = parser.next();
    }
  }

  private static BazaarStatusType getStatusType(final String group) {
    if (group.equals(ADDED)) {
      return BazaarStatusType.CREATED;
    } else if (group.equals(REMOVED)) {
      return BazaarStatusType.DELETED;
    } else if (group.equals(RENAMED)) {
      return BazaarStatusType.RENAMED;
    } else if (group.equals(MODIFIED)) {
      return BazaarStatusType.MODIFIED;
    } else if (group.equals(KIND_CHANGED)) {
      return BazaarStatusType.KIND_CHANGED;
    } else if (group.equals(UNKNOWN)) {
      return BazaarStatusType.UNKNOWN;
    } else if (group.equals(CONFLICTS)) {
      return BazaarStatusType.HAS_CONFLICTS;
    }
    return null;
  }

  private static File getAsFile(final String relativePathTofile) {
    if (relativePathTofile != null && !"".equals(relativePathTofile)) {
      return new File(relativePathTofile);
    }
    return null;
  }

  private Set<IBazaarStatus> orderAndCleanup() {
    final Map<String, List<IBazaarStatus>> map = new HashMap<String, List<IBazaarStatus>>();
    for (IBazaarStatus status : statuses) {
      List<IBazaarStatus> list = map.get(status.getPath());
      if (list == null) {
        list = new ArrayList<IBazaarStatus>();
        map.put(status.getPath(), list);
      }
      list.add(status);
    }
    return unifyStatuses(map);
  }

  private static Set<IBazaarStatus> unifyStatuses(Map<String, List<IBazaarStatus>> map) {
    final Set<String> keySet = map.keySet();
    final Set<IBazaarStatus> set = new HashSet<IBazaarStatus>(keySet.size());
    for (String key : keySet) {
      CommandLineStatus keeped = null;
      for (IBazaarStatus status : map.get(key)) {
        if (keeped == null) {
          keeped = (CommandLineStatus)status;
        } else {
          keeped.merge(status);
        }
      }
      set.add(keeped);
    }
    return set;
  }

  public List<IBazaarStatus> parseForLog(final XMLStreamReader logParser, final String endTag)
      throws XMLStreamException, IOException {
    statuses.clear();
    parser = logParser;
    int eventType = parser.next();
    while ((!endTag.equals(parser.getLocalName()) && eventType != XMLStreamConstants.END_ELEMENT)) {
      if (eventType == XMLStreamConstants.START_ELEMENT && isGroup(parser.getLocalName())) {
        parseGroup();
      }
      eventType = parser.next();
    }
    final Set<IBazaarStatus> mergedSet = orderAndCleanup();
    return Arrays.asList(mergedSet.toArray(new IBazaarStatus[mergedSet.size()]));
  }

}
