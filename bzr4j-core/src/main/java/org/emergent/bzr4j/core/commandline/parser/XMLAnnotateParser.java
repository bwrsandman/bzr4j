/**
 * LICENCSE + COPYRIGHT
 */
package org.emergent.bzr4j.core.commandline.parser;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

/**
 * I'm a parser for the output generated by the command: xmlannotate (using
 * bzr-xmloutput plugin)
 *
 * @author Guillermo Gonzalez
 *
 */
class XMLAnnotateParser extends XmlAbstractParser {

  private final List<String> revisionByLine = new ArrayList<String>();

  private final List<String> authorByLine = new ArrayList<String>();

  private final List<String> dateByLine = new ArrayList<String>();

  private final List<String> fidByLine = new ArrayList<String>();

  private final List<String> lines = new ArrayList<String>();

  File branchRoot;

  File file;

  private static final String ANNOTATE = "annotation";

  private static final String FILE = "file";

  private static String BRANCH_ROOT = "workingtree-root";

  private static final String ENTRY = "entry";

  private static final String REVISION = "revno";

  private static final String FID = "fid";

  private static final String AUTHOR = "author";

  private static final String DATE = "date";

  public void parse(String xml) throws XMLStreamException, IOException {
    try {
      XMLInputFactory factory = XMLInputFactory.newInstance();
      parser = factory.createXMLStreamReader(new StringReader(xml));
      while (true) {
        int eventType = parser.getEventType();
        if (eventType == XMLStreamConstants.END_DOCUMENT) {
          parser.close();
          break;
        }
        if (eventType == XMLStreamConstants.START_ELEMENT && ANNOTATE.equals(parser.getLocalName())) {
          branchRoot = new File(parser.getAttributeValue(null, BRANCH_ROOT));
          file = new File(parser.getAttributeValue(null, FILE));
          parseAnnotate();
        }
        parser.next();
      }
    }
    catch (XMLStreamException e) {
      LOG.error(e.getMessage(), e);
      throw e;
    }
    catch (IOException e) {
      LOG.error(e.getMessage(), e);
      throw e;
    }
  }

  private void parseAnnotate() throws XMLStreamException, IOException {
    revisionByLine.clear(); // this seems to be the intention here (to clear the list.)
    authorByLine
        .clear();   // re-instantiating had the same end effect. without the implicit clarity on why it was done.
    dateByLine.clear();
    lines.clear();
    fidByLine.clear();
    String revno, fid, author, date, line;
    int eventType = parser.next();
    // while (eventType != XmlPullParser.END_DOCUMENT &&
    // group.equals(parser.getName())) {
    while (eventType != XMLStreamConstants.END_DOCUMENT || (eventType == XMLStreamConstants.END_ELEMENT
        && ANNOTATE.equals(parser.getLocalName()))) {
      if (eventType == XMLStreamConstants.START_ELEMENT && ENTRY.equals(parser.getLocalName())) {
        revno = fid = author = date = line = null;
        for (int i = 0; i < parser.getAttributeCount(); i++) {
          if (REVISION.equals(parser.getAttributeLocalName(i))) {
            revno = parser.getAttributeValue(i);
          } else if (FID.equals(parser.getAttributeLocalName(i))) {
            fid = parser.getAttributeValue(i);
          } else if (AUTHOR.equals(parser.getAttributeLocalName(i))) {
            author = parser.getAttributeValue(i);
          } else if (DATE.equals(parser.getAttributeLocalName(i))) {
            date = parser.getAttributeValue(i);
          }
        }
        line = parser.getElementText();
        revisionByLine.add(revno);
        fidByLine.add(fid);
        authorByLine.add(author);
        dateByLine.add(date);
        lines.add(line);
      }
      eventType = parser.next();
    }
  }

  public String[] getAuthors() {
    return authorByLine.toArray(new String[0]);
  }

  public String[] getDates() {
    return dateByLine.toArray(new String[0]);
  }

  public String[] getFileIds() {
    return fidByLine.toArray(new String[0]);
  }

  public String[] getRevisions() {
    return revisionByLine.toArray(new String[0]);
  }

  public String[] getLines() {
    return lines.toArray(new String[0]);
  }

  public File getFile() {
    return new File(branchRoot, file.getPath());
  }

  public File getBranchRoot() {
    return branchRoot;
  }
}
