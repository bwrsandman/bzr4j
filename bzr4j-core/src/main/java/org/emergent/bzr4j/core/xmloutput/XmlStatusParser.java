/**
 * LICENSE + COPYRIGHT
 */
package org.emergent.bzr4j.core.xmloutput;

import org.emergent.bzr4j.core.BazaarException;
import org.emergent.bzr4j.core.BazaarItemKind;
import org.emergent.bzr4j.core.xmloutput.XmlBazaarStatus;
import org.emergent.bzr4j.core.BazaarStatusType;
import org.emergent.bzr4j.core.IBazaarLogMessage;
import org.emergent.bzr4j.core.IBazaarStatus;
import org.emergent.bzr4j.core.utils.StringUtil;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;

/**
 * I'm a parser for the output generated by th command: status --xml (usign
 * bzr-xmloutput plugin), and with that output I create a
 * Set&lt;IBazaarStatus&gt;
 *
 * @author Guillermo Gonzalez
 */
class XmlStatusParser extends XmlAbstractParser implements XmlStatusResult {

  private final List<IBazaarStatus> statuses = new ArrayList<IBazaarStatus>(0);

  private List<IBazaarLogMessage> pendingMerges = null;

  private Set<IBazaarStatus> statusSet = null;

  private final static String ADDED = "added";

  private final static String REMOVED = "removed";

  private final static String RENAMED = "renamed";

  private final static String MODIFIED = "modified";

  private final static String KIND_CHANGED = "kind_changed";

  private final static String UNKNOWN = "unknown";

  private final static String FILE = "file";

  private final static String DIR = "directory";

  private final static String OLDKIND = "oldkind";

  private final static String NEWKIND = "newkind";

  private final static String OLDPATH = "oldpath";

  private final static String FID = "fid";

  private final static String SUFFIX = "suffix";

  private final static String STATUS = "status";

  private final static String BRANCH_ROOT = "workingtree_root";

  private final static String CONFLICTS = "conflicts";

  private final static String CONFLICT = "conflict";

  private final static String TYPE = "type";

  private final static String PENDING_MERGES = "pending_merges";

  public void parse(final String xml) throws BazaarException {
    try {
      XMLInputFactory factory = XMLInputFactory.newInstance();
      parser = factory.createXMLStreamReader(new StringReader(xml));
      int eventType = parser.getEventType();
      while (eventType != XMLStreamConstants.END_DOCUMENT) {
        if (eventType == XMLStreamConstants.START_ELEMENT && isGroup(parser.getLocalName())) {
          parseGroup();
        } else if (eventType == XMLStreamConstants.START_ELEMENT && STATUS.equals(parser.getLocalName())) {
          workDir = new File(parser.getAttributeValue(null, BRANCH_ROOT));
        } else if (eventType == XMLStreamConstants.START_ELEMENT && PENDING_MERGES.equals(parser.getLocalName())) {
          parsePendingMerges();
        }
        eventType = parser.next();
      }
    }
    catch (XMLStreamException e) {
      throw new BazaarException(e);
    }
    catch (IOException e) {
      throw new BazaarException(e);
    }
    statusSet = orderAndCleanup();
  }

  public Set<IBazaarStatus> getStatusSet() {
    return statusSet;
  }

  public List<IBazaarLogMessage> getPendingMerges() {
    if (pendingMerges == null) {
      pendingMerges = Collections.EMPTY_LIST;
    }
    return pendingMerges;
  }

  private void parsePendingMerges() throws BazaarException {
    LOG.debug("Parsing pending merges");
    try {
      pendingMerges = new XmlLogParser().parse(parser);
    }
    catch (Exception e) {
      LOG.error(e, "unexpected error while parsing pending merges: ");
      pendingMerges = null;
    }
    if (pendingMerges == null) {
      pendingMerges = new ArrayList<IBazaarLogMessage>(0);
    }
  }

  private boolean isGroup(String name) {
    return (name.equals(ADDED) || name.equals(REMOVED) || name.equals(RENAMED)
        || name.equals(MODIFIED) || name.equals(KIND_CHANGED)
        || name.equals(UNKNOWN)) || name.equals(CONFLICTS);
  }

  private void parseGroup() throws XMLStreamException, IOException {
    String group = parser.getLocalName();
    LOG.debug("Parsing status group: " + group);
    int eventType = parser.next();
    while (eventType != XMLStreamConstants.END_DOCUMENT) {
      if (eventType == XMLStreamConstants.START_ELEMENT && CONFLICT.equals(parser.getLocalName())) {
        final String type = parser.getAttributeValue(null, TYPE);
        final String path = StringUtil.nullSafeTrim(parser.getElementText());
        if ((path.endsWith(".BASE") || path.endsWith(".THIS") || path.endsWith(".OTHER"))) {
          eventType = parser.next();
          continue;
        }
        // TODO: add conflict type enum
        XmlBazaarStatus.Builder builder = new XmlBazaarStatus.Builder();
        builder.setBranchRoot(workDir)
            .setPath(getAsFile(path))
            .setKind(BazaarItemKind.conflict)
            .addStatusTypes(getStatusType(group));
        final IBazaarStatus status = builder.createBazaarStatus();
        statuses.add(status);
      } else if (eventType == XMLStreamConstants.START_ELEMENT &&
          (FILE.equals(parser.getLocalName()) || DIR.equals(parser.getLocalName()))) {
        String path, prevPath;
        path = prevPath = null;
        BazaarItemKind newKind;
        BazaarItemKind oldKind = null;
        if (FILE.equals(parser.getLocalName())) {
          newKind = BazaarItemKind.file;
        } else {
          newKind = BazaarItemKind.directory;
        }
        for (int i = 0; i < parser.getAttributeCount(); i++) {
          if (parser.getAttributeLocalName(i).equals(OLDKIND)) {
            oldKind = BazaarItemKind.valueOf(StringUtil.nullSafeTrim(parser.getAttributeValue(i)));
          } else if (parser.getAttributeLocalName(i).equals(OLDPATH)) {
            prevPath = StringUtil.nullSafeTrim(parser.getAttributeValue(i));
          } else if (parser.getAttributeLocalName(i).equals(FID)) {
            // do nothing (for the moment)
          } else if (parser.getAttributeLocalName(i).equals(SUFFIX)) {
            // do nothing (for the moment)
          }
        }
        path = StringUtil.nullSafeTrim(parser.getElementText());
        if (path.endsWith(".BASE") || path.endsWith(".THIS") || path.endsWith(".OTHER")) {
          eventType = parser.next();
          continue;
        }
        XmlBazaarStatus.Builder builder = new XmlBazaarStatus.Builder();
        builder.setBranchRoot(workDir)
            .setPath(getAsFile(path))
            .setOldPath(getAsFile(prevPath))
            .setKind(newKind)
            .setOldKind(oldKind)
            .addStatusTypes(getStatusType(group));
        final IBazaarStatus status = builder.createBazaarStatus();
        statuses.add(status);
      } else if (eventType == XMLStreamConstants.END_ELEMENT && group.equals(parser.getLocalName())) {
        return;
      }
      eventType = parser.next();
    }
  }

  private static BazaarStatusType getStatusType(final String group) {
    if (group.equals(ADDED)) {
      return BazaarStatusType.CREATED;
    } else if (group.equals(REMOVED)) {
      return BazaarStatusType.DELETED;
    } else if (group.equals(RENAMED)) {
      return BazaarStatusType.RENAMED;
    } else if (group.equals(MODIFIED)) {
      return BazaarStatusType.MODIFIED;
    } else if (group.equals(KIND_CHANGED)) {
      return BazaarStatusType.KIND_CHANGED;
    } else if (group.equals(UNKNOWN)) {
      return BazaarStatusType.UNKNOWN;
    } else if (group.equals(CONFLICTS)) {
      return BazaarStatusType.HAS_CONFLICTS;
    }
    return null;
  }

  private static File getAsFile(final String relativePathTofile) {
    if (relativePathTofile != null && !"".equals(relativePathTofile)) {
      return new File(relativePathTofile);
    }
    return null;
  }

  private Set<IBazaarStatus> orderAndCleanup() {
    return XmlBazaarStatus.orderAndCleanup(statuses);
  }

  public List<IBazaarStatus> parseForLog(final XMLStreamReader logParser, final String endTag)
      throws XMLStreamException, IOException {
    statuses.clear();
    parser = logParser;
    int eventType = parser.next();
    while ((!endTag.equals(parser.getLocalName()) && eventType != XMLStreamConstants.END_ELEMENT)) {
      if (eventType == XMLStreamConstants.START_ELEMENT && isGroup(parser.getLocalName())) {
        parseGroup();
      }
      eventType = parser.next();
    }
    final Set<IBazaarStatus> mergedSet = orderAndCleanup();
    return Arrays.asList(mergedSet.toArray(new IBazaarStatus[mergedSet.size()]));
  }

}
